package code03_binarySearch;


/*时间复杂度｜空间复杂度*/
public class Code04_complexity {

    /*1.冒泡排序的时间复杂度*/
//    冒泡排序的时间复杂度是 O(n^2)，其中 n 是待排序数组的元素个数。
//
//    冒泡排序的基本思想是通过反复交换相邻的元素，将较大的元素逐渐“浮”到数组的末尾，而较小的元素则逐渐“沉”到数组的前端。具体步骤如下：
//            1. 从数组的第一个元素开始，通过比较相邻的两个元素，如果前面的元素大于后面的元素，则交换它们的位置。
//            2. 对数组中的每一对相邻元素重复执行步骤1，直到最后一对元素。此时，最大的元素将会“浮”到数组的末尾。
//            3. 重复执行步骤1和步骤2，但是每次内部循环的比较次数减少1，直到没有需要交换的元素为止。
//
//    由于冒泡排序的每一轮内部循环都会将一个最大的元素放置在正确的位置上，所以总共需要执行 n-1 轮内部循环。每一轮内部循环的比较次数为 n-1，所以总的比较次数为 (n-1) * (n-1) = n^2 - 2n + 1。
//    由于时间复杂度通常省略低次和常数项，所以冒泡排序的时间复杂度被表示为 O(n^2)。


    /*2.选择排序的时间复杂度*/
//    选择排序的时间复杂度是 O(n^2)，其中 n 是待排序数组的元素个数。
//
//    选择排序的基本思想是每次从未排序部分选择最小（或最大）的元素，并将其放置在已排序部分的末尾。具体步骤如下：
//
//            1. 在未排序部分中找到最小（或最大）的元素。
//            2. 将找到的最小（或最大）元素与未排序部分的第一个元素交换位置，将其放置在已排序部分的末尾。
//            3. 重复步骤1和步骤2，直到未排序部分为空。
//
//    选择排序的内部循环会将一个最小（或最大）的元素放置在已排序部分的末尾，因此总共需要执行 n-1 轮内部循环。每一轮内部循环的比较次数是固定的，为 n-1。
//    因此，选择排序的总比较次数为 (n-1) * (n-1) = n^2 - 2n + 1。
//    由于时间复杂度通常省略低次和常数项，所以选择排序的时间复杂度被表示为 O(n^2)。


    /*3.二分法的时间复杂度*/
//    二分法的时间复杂度是 O(log n)，其中 n 是待搜索区间的大小。
//
//    二分法是一种通过将待搜索区间划分为两个较小的子区间，并根据目标值与子区间的中间值的大小关系来确定目标值可能出现的位置的搜索算法。具体步骤如下：
//
//            1. 确定待搜索区间的起始点和结束点，通常为整个数组或有序数组的范围。
//            2. 取待搜索区间的中间位置的元素作为中间值。
//            3. 将目标值与中间值进行比较。如果目标值等于中间值，则搜索结束，找到目标值。如果目标值小于中间值，则目标值可能出现在中间值左侧的子区间。如果目标值大于中间值，则目标值可能出现在中间值右侧的子区间。
//            4. 根据步骤3的比较结果，将待搜索区间缩小为子区间并重复步骤2和步骤3，直到找到目标值或待搜索区间为空。
//
//    每次执行二分法，搜索区间都会缩小为原来的一半。因此，如果待搜索区间的大小是 n，那么经过 k 次划分后，搜索区间的大小将变为 n/2^k。
//    当最终找到目标值时，搜索区间的大小为1，即 n/2^k = 1，解得 k = log2(n)。因此，二分法的时间复杂度为 O(log n)。  可能是log7，log2，log3，因为无论是多少，n都很小，所以无所谓

    /*
    * 1.常数的时间复杂度 为 O(1)
    * 2.要用最差的情况的时间复杂度才是时间复杂度
    * */

//    以下是常见的时间复杂度列表，按照从小到大的顺序排列：
//     1. O(1)：常数时间复杂度，表示算法的执行时间是一个常量。
//     2. O(log n)：对数时间复杂度，表示算法的执行时间与输入规模的对数成正比。例如，二分查找算法的时间复杂度就是 O(log n)。
//     3. O(n)：线性时间复杂度，表示算法的执行时间与输入规模成线性关系。例如，遍历一个数组的时间复杂度就是 O(n)。
//     4. O(n log n)：线性对数时间复杂度，表示算法的执行时间与输入规模的对数乘以线性关系。例如，快速排序和归并排序的时间复杂度就是 O(n log n)。
//     5. O(n^2)：平方时间复杂度，表示算法的执行时间与输入规模的平方成正比。例如，冒泡排序和插入排序的时间复杂度就是 O(n^2)。 可能会有n的三次方，四次方，五次方等等
//     6. O(2^n)：指数时间复杂度，表示算法的执行时间与输入规模呈指数关系。例如，求解旅行商问题的暴力穷举算法的时间复杂度就是 O(2^n)。
//     7. O(n!)：阶乘时间复杂度，表示算法的执行时间与输入规模的阶乘成正比。例如，求解旅行商问题的全排列算法的时间复杂度就是 O(n!)。


    /*动态数组的时间复杂度*/
//    动态数组的扩容操作涉及到将原数组中的元素复制到新的内存空间中，因此扩容的时间复杂度取决于元素复制的数量。通常情况下，动态数组的扩容策略是一种动态增长的策略，比如每次扩容将原来的容量增加一倍。
//    假设原动态数组的长度为 n，当需要扩容时，通常会将原数组中的元素复制到新的长度为 2n 的内存空间中。因此，扩容操作的时间复杂度可以被表示为 O(n)。
//    需要注意的是，由于扩容操作不是在每一次添加元素时都进行的，而是在动态数组的内部实现中通过一些策略来确定何时进行扩容，因此对于一系列添加元素的操作，扩容操作的总体时间复杂度可以被均摊为 O(1)。


}
