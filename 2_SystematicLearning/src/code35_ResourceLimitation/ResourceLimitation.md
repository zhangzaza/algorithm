# 资源限制技巧汇总

1. 布隆过滤器用于集合的建立与查询，并可以节省大量空间
2. 一致性哈希解决数据服务器的负载管理问题
3. 利用并查集结构做到问题的并行计算
4. 哈希函数可以把数据按照种类均匀分流
5. 为徒解决某一范围上数据的出现问题，并可以节省大量空间
6. 利用分段统计思想，并进一步节省大量空间
7. 利用堆来做多个处理单元的结果合并



## 1.题目一

32位无符号整数的范围是 0～4294967295，

心在有一个整好包含40亿个无符号整数的文件，

可以使用最多1GB 的内存，怎么找到出现次数最多的数？



### 1.1.排除排序「错误」

>32 位无符号整数
>
>- 每个整数4字节。
>- 总大小 = 40亿 × 4 字节 = 160亿字节。
>- 换算为更常用的单位：
>  - 千字节（KB）：160亿字节 / 1024 ≈ 156250000 KB
>  - 兆字节（MB）：156250000 KB / 1024 ≈ 152587.89 MB
>  - 千兆字节（GB）：152587.89 MB / 1024 ≈ 149.01 GB
>
>64 位无符号整数，那么每个整数占用 8 字节，计算方法类似，最终大小会翻倍：
>
>- 总大小 = 40亿 × 8 字节 = 320亿字节。
>- 换算为更常用的单位：
>  - 千字节（KB）：320亿字节 / 1024 ≈ 312500000 KB
>  - 兆字节（MB）：312500000 KB / 1024 ≈ 305175.78 MB
>  - 千兆字节（GB）：305175.78 MB / 1024 ≈ 298.02 GB
>
>因此，40亿个32位无符号整数大约需要149.01 GB的存储空间，而40亿个64位无符号整数则需要约298.02 GB的存储空间。



### 1.2.使用hash表「正确」

key：int，value：int

如果是全部一起的话：40亿 * 8 ： 32G 这肯定不行

**正确做法如下：**

1G 哈希表 能装的数据：1GB / （4+4）字节 =125,000,000 条数据

所以假设 哈希表只能装 1亿条数据 或者 1千万条数据

最差的为 40亿分别是 40亿种不同的数

40亿 / 1千万 = 400

所以 将 40亿数据 取哈希 再 %400 ，使得40亿条数会均匀的分布在 这一千万的范围上

所以同一种数字只会进入同一个文件，现在拿到了 0～400个文件，每个文件的字符种类只会多出一点

400 个文件，然后在每个文件中找出 字符最大的文件 再进行比较





## 2.题目二

### 2.1.基础「使用位图」

32位无符号整数的范围是 0～4294967295，

心在有一个整好包含40亿个无符号整数的文件，

所以在整个范围中必然存在没出现过的数。

可以使用最多1GB的内存，怎么找到所有未出现过的数？

#### **位图大小计算**：

>- 32 位无符号整数的范围是 0 到 4,294,967,295。
>- 需要一个位图来表示这些数字中每个数字的出现情况。
>- 每个数字用 1 位表示是否出现过。
>- 位图大小 = 232232 位 = 4,294,967,296 位。
>- 换算为字节：4,294,967,2968=536,870,91284,294,967,296=536,870,912 字节 = 512 MB。



#### **实现步骤**

>- **初始化位图**：创建一个大小为 512 MB 的字节数组，每个位初始设置为 0。
>
>- 读取文件并更新位图
>
>  ：
>
>  - 逐个读取文件中的整数。
>  - 对于每个整数 n
>    - 计算其在位图中的位置：`n / 8` 确定字节索引，`n % 8` 确定在字节中的位偏移。
>    - 设置对应位为 1 来表示该整数已经出现过。
>
>- 查找未出现的数
>
>  - 遍历位图中的每一位。
>  - 如果某个位仍然为 0，则对应的整数未出现过。



#### **复杂度与效率**

>- **时间复杂度**：O(N)，其中 N 是整数个数，即 40 亿。遍历文件和位图的时间复杂度都是线性的。
>- **空间复杂度**：512 MB（位图），符合 1GB 内存的限制。



### 2.2.进阶「512分」

内存限制为 3 KB，但是只用找到一个没出现过的数即可

**解题思路：**

1. 无符号一个正数为4字节，3000kb/4字节{一个int 是4字节} =750 
2. 申请一个小于750 的最大2的幂次方：512
3. 创建 new int[512]
4.  4294967295 / 512 =8,388,608
5. 如果数组中某个数字不是 这个数字，就是不满，就针对这个范围再进行 512 ，直到找到





### 2.3.超进阶「2分」

如果只有有限几个变量

**解题思路：**

L[...mid...]R

哪个区域范围不够 2的31次，再针对那个部分进行二分





## 3.题目三「找出现了两次」

32位无符号整数的范围是 0～4294967295，

现在有40亿个无符号整数，

可以使用最多1GB的内存，找出所有出现了两次的数



**解题思路：**

1. **位图数据结构**：
   - 使用一个 `byte[]` 数组，其中每个字节存储 4 个整数的状态。
   - 每个整数的状态使用两位表示：
     - **00**：未出现。
     - **01**：出现一次。
     - **10**：出现两次。
     - **11**：出现多次（忽略不处理，因为我们只关心出现两次的整数）。
2. **步骤**：
   - **初始化**：创建一个 `byte[]` 数组，其大小为 232/4=230232/4=230 字节。
   - **遍历输入**：通过位操作更新每个整数对应的 2 位状态。
   - **输出**：遍历数组，找出标记为 10 的整数。





## 4.题目四「模分+分治」

32位无符号整数的范围是 0～4294967295，

现在有40亿个无符号整数，

可以使用最多10MB的内存，怎么找到这40亿个整数的中位数？



**解题思路：**

1. 无符号一个正数为4字节，3000kb/4字节{一个int 是4字节} =750 
2. 申请一个小于750 的最大2的幂次方：512
3. 创建 new int[512]
4.  4294967295 / 512 =8,388,608
5. 得到了一个数组 并且 数组上的某一段划分了等大小8,388,608 的数字
6. 使用有限变量，开始遍历 arr[1]+arr[2] 往右边加，直到变为 40亿 的一半多
7. 确定中位数出现的范围 也就是在需要拿到  8,388,608*i 这个范围内的第 40亿 - (arr[1]+.....+arr[i-1])





## 5.题目五「大根堆」

32bit位无符号整数的范围是0~4294967295

有一个10G大小的文件，每一行都装着这种类型的数字整个文件是无序的，给你5G的内存空间:

请你输出一个10G大小的文件，就是原文件所有数字排序的结果



解题思路：

1. 创建一个大根堆，里面只有固定的容量「5GB / (int4字节 + long 8字节) 『每个堆的位置为 数字 + 词频』」 保险起见的话容器大小可以小一些
2. 遍历一遍文件，因为容器是固定容量，加入规格如下：
   1. 加入新的数，则加入 该数字，词频为1，如果不是新的数，直接词频+1
   2. 如果size达到了大小，又来新的数，判断该数字的大小是否大雨peek，如果小于，则poll，再将这个数字作为新数字加入
3. 遍历结束之后，再对该容器进行遍历填充10G的输出文件「数字+词频都知道了，那就好填写了」，并且记住容器中大根堆的poll的最大值,记作pollMax
4. 第二次开始遍历原先的10GB文件，但是小于pollMax的数不看一眼
5. 直到结束「这里结束的话，在第一次遍历的时候拿到了10GB的最大值，如果某次结束的时候，该数字出现在了pollMax中，则不用再遍历了」



## 6.外排序的概念

>外排序是一种用于处理数据量大于内存容量的排序算法。它通过利用磁盘等外部存储设备来进行排序，通常分为两个阶段：**分块排序和归并排序**。以下是外排序的详细解释：
>
>### 外排序的步骤
>
>1. **分块排序**：
>   - 首先，将大文件分成多个较小的块，每个块的大小可容纳在内存中。
>   - 对每个块进行内部排序（例如，使用快速排序、归并排序等），然后将排序后的结果写回磁盘，形成多个已排序的小文件。
>2. **多路归并**：
>   - 在第二阶段，将这些已排序的小文件进行合并。
>   - 使用一个多路归并算法（通常使用优先队列或最小堆），从每个小文件中读取最小元素进行合并，直到所有文件都被合并完成，最终生成一个排序后的大文件。





