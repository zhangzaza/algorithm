package code10_List_SortSummary;

public class Code01_SortSummary {

/** 基于比较的排序*/
//总结
//排序算法		时间复杂度（平均）	    额外空间复杂度	稳定性
//选择排序	         O(n^2)	          O(1)	         否       //扑克牌
//冒泡排序	         O(n^2)	          O(1)	         是
//插入排序	         O(n^2)	          O(1)	         是
//归并排序	         O(n log n)	      O(n)	         是       //合并两边数组分开
//随机快排		     O(n log n)	      O(log n)	     否       //中间找相等数组的前后标，荷兰国旗
//堆排序	             O(n log n)	      O(1)	         否       //二叉树
//计数排序		     O(n + k)	      O(k)	         是
//基数排序		     O(n * k)	      O(n + k)	     是

/** 排序算法总结*/
/*
* 1.不基于比较的排序，对样本数据有严格要求，不易更改
* 2.基于比较的排序，只要规定好两个样本怎么比大小就可以直接复用
* 3.基于比较的排序，时间复杂度的极限是O(N*logN)
* 4.时间复杂度O(N*logN),额外空间复杂度低于O(N),且稳定的基于比较的排序是不存在的
* 5.为了绝对的速度排序选择快排，为了省空间选择堆排序，为了稳定性选择归并
* */


    //注意点：如果是数据量比较小的情况下，要找最好的排序，上述只是对于大样本随机的数据，统一来说，但是针对不同的场景，还需要不同的排序


/*
* 工程上对排序的改进
* 1.稳定性的考虑
* 2.充分利用O(N*logN)和O(N*2)排序各自的优势
* */

}
