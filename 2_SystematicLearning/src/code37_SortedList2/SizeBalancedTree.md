
## 1.什么是Size-Balanced Tree
### Size-Balanced Tree的主要特点

1. **大小平衡**：
   - 每个节点维护其子树的大小（即包括自身在内的节点总数）。
   - 通过调整节点间的关系，确保左右子树的节点数量满足特定的平衡条件。

2. **平衡条件**：
   - 对于每个节点，其左右子树的大小需要满足特定的比例关系。这种条件保证了树的高度是对数级别，从而确保操作的效率。

3. **旋转操作**：
   - 在插入或删除操作后，如果发现某个节点的平衡条件被破坏，会通过旋转操作来恢复平衡。
   - 旋转操作类似于AVL树和红黑树，分为左旋和右旋。

4. **操作复杂度**：
   - 插入、删除和查找操作的平均时间复杂度为O(log n)，保证了高效的动态操作。

### Size-Balanced Tree的优势

- **实现简单**：相比一些复杂的自平衡树，大小平衡树的实现可能更为直观。
- **高效性**：通过维护节点的大小信息，可以更快速地进行平衡调整。

### 应用场景

Size-Balanced Tree适用于需要快速动态调整且对实现简单性有要求的场景。它兼具高效性和一定的实现灵活性，因此在某些应用中可能比传统的AVL树或红黑树更具优势。


## 2.Size-Balanced Tree 和 AVL树是什么关系

Size-Balanced Tree（大小平衡树）和AVL树都是自平衡二叉搜索树的实现，但它们在保持平衡的策略和具体实现细节上有所不同。以下是它们之间的关系和区别：

### 共同点

1. **自平衡特性**：
   - 两者都是自平衡二叉搜索树，旨在在插入、删除和查找操作时保持高效的性能。
   - 两者都通过某种平衡机制确保树的高度维持在对数级别，因此操作的时间复杂度为O(log n)。

2. **操作相似性**：
   - 都支持常见的动态集合操作，比如插入、删除和查找。

### 不同点

1. **平衡条件**：
   - **AVL树**：通过维护每个节点的平衡因子（左右子树高度之差的绝对值不超过1）来实现平衡。
   - **Size-Balanced Tree**：通过维护每个节点的子树大小，并确保左右子树的大小差满足特定条件来实现平衡。

2. **维护信息**：
   - **AVL树**：每个节点存储平衡因子或子树高度。
   - **Size-Balanced Tree**：每个节点存储子树的大小。

3. **旋转操作**：
   - **AVL树**：在插入或删除后，如果平衡因子被破坏，会进行单旋或双旋来恢复平衡。
   - **Size-Balanced Tree**：通过旋转操作，根据子树大小条件来恢复平衡，旋转的条件和时机与AVL树有所不同。

4. **实现复杂度**：
   - **AVL树**：严格的平衡条件可能导致实现稍微复杂，但保证了非常好的平衡性。
   - **Size-Balanced Tree**：可能实现稍简单，因为它只需要维护子树大小，而不需要高度信息。

### 使用场景

- **AVL树**：适用于需要严格平衡和快速查找的场景，因为它对高度的严格控制使得查找操作非常高效。
- **Size-Balanced Tree**：在某些场景中可能提供更简单的实现，并且在某些类型的动态操作中可能具有更好的性能表现。



## 3.Size-Balanced Tree的 平衡性调整
在add的时候调整，在delete时候不调整，时间复杂度为O(logn)「n为树的节点数『n为这棵树曾经冲到的最大值』」。
AVL树 只做两个动作，没有后续的递归传递，但是Size-Balanced Tree有。


