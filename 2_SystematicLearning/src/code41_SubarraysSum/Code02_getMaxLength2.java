package code41_SubarraysSum;


import java.util.HashMap;

/// 给定一个整数组成的无序数组arr，值可能是正，可能是负，可能0
/// 给定一个整数值K
/// 找到arr的所有子数组里，哪个子数组的累加和 = K，并且是长度最大的，返回其长度
///
/// 变化：在一个数组数组中，求出这个数组中一段长度内，-1和1的长度的最长子数组 范围
/// 思路：根据上述的模型，求出 和 为 0 的时候的最长的长度即可，先把整个数组中所有不是1和-1的数字都变成0

public class Code02_getMaxLength2 {


    public static int getMaxLength(int[] arr, int k) {
        if (arr == null || arr.length == 0 || k <= 0){
            return 0;
        }
        // key:前缀和
        // value:0～value 这个前缀和事最早出现key这个值的
        HashMap<Integer, Integer> map = new HashMap<>();
        map.put(0, -1);
        int len =0;
        int sum =0;
        for (int i = 0; i < arr.length; i++) {
            sum += arr[i];
            if (map.containsKey(sum - k)){
                len = Math.max(len, i - map.get(sum - k));
            }
            if (!map.containsKey(sum)){
                map.put(sum, i);
            }
        }
        return len;

    }

}



/// 子数组和子序列是两个在处理数组或列表时常用的概念，它们有着不同的定义和特性：
///
/// ### 子数组
///
/// - **定义**：子数组是原数组中连续的一段。它是通过选择数组中的一个起始位置和一个终止位置来定义的，包含这两个位置之间的所有元素。
/// - **特性**：由于子数组必须是连续的，所以对于长度为 \( n \) 的数组，它的子数组数量是 \(\frac{n(n+1)}{2}\)，因为每个可能的起始位置和终止位置组合都定义了一个子数组。
/// - **例子**：对于数组 \([1, 2, 3]\)，子数组包括 \([1]\), \([2]\), \([3]\), \([1, 2]\), \([2, 3]\) 和 \([1, 2, 3]\)。
///
/// ### 子序列
///
/// - **定义**：子序列是通过从原数组中选择一些元素按照原来的顺序排列形成的，但这些元素不一定是连续的。子序列可以通过选择是否包含每个元素来定义。
/// - **特性**：子序列可以是不连续的，这意味着子序列的数量比子数组要多得多。对于一个长度为 \( n \) 的数组，它的子序列的数量是 \(2^n\)（包括空子序列）。
/// - **例子**：对于数组 \([1, 2, 3]\)，子序列包括 \([], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]\)。
///
/// ### 总结
///
/// - **连续性**：子数组必须是连续的，而子序列可以是不连续的。
/// - **数量**：子数组的数量少于子序列，因为子数组的元素必须连续。
/// - **应用场景**：子数组通常用于需要保持元素连续性的场景，如最大子数组和问题；子序列常用于需要考虑所有可能组合的场景，如最长递增子序列问题。

