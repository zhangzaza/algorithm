
### 主要数据结构

1. **`arr[]`**: 存储原始数组的信息。注意在这段代码中，`arr`数组的索引从1开始，即`arr[0]`未被使用。

2. **`sum[]`**: 线段树的节点，存储每个节点对应区间的和。

3. **`lazy[]`**: 懒惰标记数组，用于延迟更新的加法操作。它记录了每个区间的增量值，只有在必要时才将其应用到`sum[]`中。

4. **`change[]`**: 用于更新操作的数组，记录了每个区间需要更新成的值。

5. **`update[]`**: 布尔数组，标记某个区间是否需要进行更新操作。

### 核心方法

1. **构造函数 `SegmentTree(int[] originArr)`**: 初始化线段树的各个数组，并将原始数组的数据复制到`arr[]`中。注意`arr`的索引偏移了1。

2. **`build(int l, int r, int rt)`**: 构建线段树。`l`和`r`表示当前处理的数组区间，`rt`表示在`sum[]`中的位置（即线段树节点号）。如果`l==r`，表示该节点是一个叶子节点，直接从`arr[]`中读取元素值。否则，递归地构建左右子树，并通过`pushUp(rt)`合并左右子树的信息。

3. **`pushDown(int rt, int ln, int rn)`**: 懒惰标记的下推操作。如果当前节点有更新任务，则将更新任务传递给左右子节点，并清空父节点的更新标记。如果有累加任务，则对左右子节点的`sum`和`lazy`进行更新。

4. **`pushUp(int rt)`**: 将左右子树的区间和更新到当前节点的区间和中，用于在局部变化后更新父节点。

5. **`add(int L, int R, int C, int l, int r, int rt)`**: 支持区间加法操作。在区间`[L, R]`上增加一个值`C`。如果当前节点所表示的区间完全包含在`[L, R]`中，则直接更新`sum[]`和`lazy[]`。否则，将任务递归地传递给左右子节点。

6. **`update(int L, int R, int C, int l, int r, int rt)`**: 支持区间更新操作。在区间`[L, R]`上将所有值更新为`C`。如果当前节点所表示的区间完全包含在`[L, R]`中，更新`sum[]`，`change[]`和`update[]`。如果不完全包含，则下推更新标记，并递归处理子节点。

7. **`query(int L, int R, int l, int r, int rt)`**: 查询区间和。在区间`[L, R]`内查询和。如果当前节点所表示的区间完全包含在`[L, R]`中，直接返回`sum[]`。否则，递归查询左右子树，并返回结果的和。

### 特点

- **懒惰标记**: 用于优化更新和查询操作，当一个区间有更新任务时，该任务会延迟到真正需要时才执行，避免不必要的操作，从而提高效率。

- **区间加法和赋值更新**: 此线段树实现支持区间的增量更新和赋值更新，提供了灵活的功能。

- **时间复杂度**: 每次查询和更新操作的时间复杂度为 O(log n)，非常适合处理需要频繁更新和查询的大规模数据集。

